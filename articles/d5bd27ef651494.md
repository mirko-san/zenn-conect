---
title: "知識ゼロからふんわり理解する OAuth 2.0"
emoji: "🔐"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["oauth2"]
published: false
---

## はじめに

この文章は自分が OAuth 2.0 についてふんわり理解するために必要だった周辺知識などもあわせて紹介し、読了時に「 OAuth 2.0 ふんわり理解したなー」と思ってもらうための文章です。

### 想定読者

以下のような疑問をお抱えの方を想定しています。

- 「 OAuth 2.0 ？海のものとも山のものつかないよ？」
- 「認証？」「認可？」

### 本稿で分かること

本稿を読むことで、以下のことが分かるようになることを期待しています。

- OAuth 2.0 の仕様に沿うアプリケーションがどんなことを実現しているか分かる
- 認証と認可の違いが分かる

### （分かる人向け）本稿のスタンス

本稿では OAuth 2.0 のことは RFC6749 のみを指します。
Bearer Token や OpenID Connect なども広義の意味で OAuth 2.0 の仕様の一部と捉えられるかもしれませんが、本稿では扱いません。

## 認証

「認証」とは何でしょうか？
それを本稿では「本人かどうか確認すること」とします。
昨今「多要素認証」という単語を見聞きする機会もあるかと思いますが、「認証」には以下の 3 つの要素があるとされています。

- 知識情報
- 所持情報
- 生体情報

これはすべて「利用者が本人であるかどうか」を確認する方法です。
そして、この認証をインターネットで提供されているサービスで行うのに使うのが HTTP 認証です。（と表現します）

##### 参考

https://www.nri.com/jp/knowledge/glossary/lst/ta/multi_factor_authentication

### 認証方式

例え話をします。
ここでは以下の人物が登場します。

A さん: 「お母さん」の子ども
お母さん: A さんの母

A さんがお母さんに電話をかけたとします。お母さんがその電話をとりました。
このとき、お母さんは電話の相手が「本当に A さんかどうか？」を電話で確認する必要があるでしょう。
実際にお母さんがあなたを「本当に A さんかどうか？」をどう確認するか？というのが **認証方式** です。

たとえば、以下のような認証方式が考えられます。

方法 1（知識情報）： この間一緒に買い物に行ったときにお母さんが買ったものを A さんが答えられる
方法 2（所持情報）： A さんが電話をかけている電話の電話番号がお母さまの携帯に A さんとして既に登録されている
方法 3（生体情報）： 声が A さんであると分かる

## 認証と認可の違いを理解する

上述の電話口での認証（A さんであるかの確認）ですが、これは実は「お母さんが A さんと直接やり取りをしていること」を前提として成り立っています。
たとえば、ここで A さんはお母さんとのやりとりが電話ではなくなったとしたらどうなるでしょうか？

ある日、お母さんにメッセージアプリで A さんを名乗る以下のような連絡が来ました。

---

どうしよう！車で自己を起こしちゃった…。
被害者がちょっとヤバそうな人で明後日までにとりあえず謝礼金 20 万円を払えって言ってるんだけど、今ちょうど貯金が無くて…。
この振込先に振り込むように言われているんだけど、振り込んでくれない？

○○ 銀行 xx 支店 普通預金
番号 xxxxx

---

お母さんは思います。「これが本当なら、 A さんのために払うのも仕方がないのかもしれない。でも、この連絡は本当に A さんからのものなのだろうか…？」

そんなとき、素直に考えるとお母さんが A さんを認証するには、お母さんから A さんに電話認証をして直接確認するなどがあるかもしれません。

ですが、せっかくメッセージアプリで楽に連絡が取れるようにしたのに、話題によってはお母さんから「このメッセージはあなたのものなの？」って確認の電話が来るのは面倒ですよね。
また、それだけではありませんが、いろいろな面倒や難しさが発生してきます。
それらの難しさへのアプローチのひとつが **OAuth 2.0** です。
OAuth 2.0 では「認可レイヤー」を設けることにしました。

:::message

### 余談

上記の理解は [RFC6749](https://openid-foundation-japan.github.io/rfc6749.ja.html#anchor1) の以下の文あたりを解釈した結果です。

> 従来のクライアントサーバー型の認証モデルでは, クライアントはリソースオーナーのクレデンシャルを使ってサーバーに対して認証を行い, サーバー上の保護されたリソースにアクセスする. つまり, サードパーティーアプリケーションに保護されたリソースへのアクセス権を与えるには, リソースオーナーは自身のクレデンシャルをサードパーティーと共有する必要がある. これはいくつかの問題と制限をもたらす.
> (中略)
> OAuth は, 認可レイヤーをもうけてクライアントとリソースオーナーの役割を分けることで, これらの問題の解決に取り組む.

ですが私は OAuth 2.0 を使わないアプローチに関しては不勉強ですので、例えが不適切な場合はご指摘くださると幸いです。
:::

### 認可レイヤーがあることによる恩恵

再度、認可レイヤーが無い場合のフローを整理します。

1. A さんはメッセージアプリでメッセージの送信リクエストをする
2. メッセージアプリは送信リクエストを受け、指定の宛先にメッセージを送信する
3. お母さんがメッセージを受け取る

上記が、認可レイヤーをもうけることで下記のように変化します。

1. メッセージアプリは A さんに対して **認証** を行う
2. A さんはメッセージアプリでメッセージの送信リクエストをする
3. メッセージアプリは認可サーバーに認可リクエストをする
4. 認可サーバーは「このメッセージを A さんが送っていいと認可したものですよ」ということを示す **アクセストークン** を発行する
5. メッセージアプリは **アクセストークン** とともに指定の宛先にメッセージを送信する
6. お母さんがメッセージと **アクセストークン** を受け取る
7. お母さんは認可サーバーに対して「この **アクセストークン** は本当に A さんが認可したという内容なのか」を確認する

これで、お母さんは「特定のメッセージが A さんからのものかどうか」を **A さんに直接確認すること無く安全に** 確認できるようになりました 🎉

:::message
OAuth 2.0 のインプリシットフローをもとに、例え話として分かりやすくするために一部簡略化しています
:::

##### 参考

https://qiita.com/TakahikoKawasaki/items/200951e5b5929f840a1f#2-%E3%82%A4%E3%83%B3%E3%83%97%E3%83%AA%E3%82%B7%E3%83%83%E3%83%88%E3%83%95%E3%83%AD%E3%83%BC

### まとめ: 認証と認可の違い

認証: 本人かどうか確認する
認可: 権限を与える

という違いになります。

上記の例で言うと、認可サーバーが主に提供していることは

- アクセストークンの発行機能
- アクセストークンの検証機能

であり、認可サーバーは「このリクエストが本当に A さんのものかどうか？」の **認証** は基本的には **行いません**。

> 認可サーバーはクライアント認証の目的でネイティブアプリケーションやユーザーエージェントベースのアプリケーションにパスワードやその他のクレデンシャルを発行してはいけない (MUST NOT)

https://openid-foundation-japan.github.io/rfc6749.ja.html#anchor32

また、 OAuth 2.0 で定義していることは上記でいう「認可サーバー」周辺の仕様であり、メッセージアプリが A さんをどう認証するかについては定義していません。

:::message

### でもよく OAuth **認証** って単語がヒットするよ？

筆者の理解としては以下のどれかなのかなと思っています。

- OAuth 2.0（RFC6749） では認証について触れていないが OAuth 2.0 に付随する仕様として Barere Token での認証というのがあり、それも OAuth 2.0 の一部だと考えている人が OAuth (2.0) 認証と言っているのかもしれない
- OAuth 2.0 の仕様に沿った認可サーバーを内包した ID プロバイダー が認証の責務を負っていることがあるので、そこと混同しているのかもしれない
- OAuth 1.0 時代に書かれたドキュメントなのかもしれない
  - 私はあまり詳しくないのですが、どうやら OAuth 1.0 の頃は認証も含んだ仕様だったみたいです
  - MDN の [HTTP 認証 - 認証方式](https://developer.mozilla.org/ja/docs/Web/HTTP/Authentication#authentication_schemes) からリンクされている「[認証スキームの一覧](https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml)」に OAuth とあるので、多分そうなんだろうなと筆者は思っています

:::

#### 余談

認可についてもしここまででイメージが湧いていない場合は、鉄道などの通学定期がイメージしやすいかもしれません。

通学定期を購入する際、窓口で学生証を提示したり身分証明をするかと思いますが（筆者が学生の頃はそうでした）定期券を手に入れた後は毎度改札で身分証明はしていないと思います。
それは改札が定期券の情報を信頼しているからで、たとえば定期券が他の人に渡ってしまってもその定期券は使えてしまう（改札機は認証をしていないので）という状況になるでしょう。

上記の例えだと
認証: 定期券の発行
認可: 改札機が定期券の情報を見てこの改札を通っていいか判断する

という違いになります。イメージがわくと幸いです。

## さいごに

これで解説は以上です。
ここまで読んでみて「本稿で分かること」に書いた内容が分かっていると幸いです。

さて、ここでちょっと OAuth 2.0 について調べてみたことがある方は「OAuth 2.0 で検索するとヒットする他の記事で言及しているような ○○ について触れていないじゃないか！そこがよく分からないのに！」と思っているかもしれません。
それはその通りで、本稿では OAuth 2.0 のことを RFC6749 に限定しているため、以下のことには触れていません。

- Bearer Token: RFC6750
- JWT（と JT○）: RFC7515 - RFC7519
- OpenID Connect: OpenID Connect 1.0 specification

これらについてはもしかしたら私が記事を書くかもしれませんが、未定なので、それらの理解に役立つかもしれないリンクを貼っておきます。
お役立てください。

### 本稿では触れなかった周辺仕様の理解に役立つリンク

#### Bearer Token

https://openid-foundation-japan.github.io/rfc6750.ja.html

#### JWT（と JT○）

https://auth0.com/resources/ebooks/jp-jwt-handbook

#### OpenID Connect

https://qiita.com/TakahikoKawasaki/items/498ca08bbfcc341691fe
http://openid-foundation-japan.github.io/openid-connect-core-1_0.ja.html
